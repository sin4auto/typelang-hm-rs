// パス: src/codegen/dictionary_codegen.rs
// 役割: Core IR の辞書メタ情報からネイティブ辞書初期化コードを生成する
// 意図: バックエンドが辞書をリンクできるように自動生成ファイルとランタイム ABI を橋渡しする
// 関連ファイル: src/codegen/cranelift.rs, runtime_native/src/dict.rs

use std::cmp::Ordering;
use std::io::Write;

use tempfile::NamedTempFile;

use crate::core_ir::DictionaryInit;

use super::{NativeError, NativeResult};

#[allow(clippy::result_large_err)]
/// 収集した辞書情報から `runtime_native` 向けの自動生成ソースを出力する。
pub fn generate(dictionaries: &[DictionaryInit]) -> NativeResult<Option<NamedTempFile>> {
    if dictionaries.is_empty() {
        return Ok(None);
    }

    let mut sorted = dictionaries.to_vec();
    sorted.sort_by(|a, b| match a.classname.cmp(&b.classname) {
        Ordering::Equal => a.type_repr.cmp(&b.type_repr),
        other => other,
    });

    let mut file = NamedTempFile::new()?;
    write_header(&mut file)?;
    for dict in &sorted {
        write_dictionary(&mut file, dict)?;
    }
    file.flush()?;
    Ok(Some(file))
}

fn write_header<W: Write>(writer: &mut W) -> std::io::Result<()> {
    writeln!(
        writer,
        "// @generated by dictionary_codegen\nuse std::ffi::c_void;\n"
    )
}

#[allow(clippy::result_large_err)]
fn write_dictionary<W: Write>(writer: &mut W, dict: &DictionaryInit) -> NativeResult<()> {
    let builder_symbol = dict.builder_symbol.as_ref().ok_or_else(|| {
        NativeError::unsupported(
            "CODEGEN302",
            format!(
                "{}<{}> の辞書ビルダーシンボルが解決できません",
                dict.classname, dict.type_repr
            ),
        )
    })?;
    let label = format!("{}<{}>", dict.classname, dict.type_repr);
    writeln!(writer, "#[no_mangle]")?;
    writeln!(
        writer,
        "pub extern \"C\" fn {}() -> *mut crate::TlDictionary {{",
        builder_symbol
    )?;
    writeln!(writer, "    unsafe {{")?;
    writeln!(
        writer,
        "        let builder = crate::tl_dict_builder_new(c\"{}\".as_ptr());",
        escape_c_literal(&label)
    )?;
    writeln!(
        writer,
        "        if builder.is_null() {{ return ::std::ptr::null_mut(); }}"
    )?;
    for (idx, method) in dict.methods.iter().enumerate() {
        let method_id = method.method_id.unwrap_or(idx as u64);
        let signature = method.signature.as_deref().unwrap_or("(unknown)");
        let symbol = method.symbol.as_ref().ok_or_else(|| {
            NativeError::unsupported(
                "CODEGEN303",
                format!(
                    "辞書 {}<{}> のメソッド {} にシンボルがありません",
                    dict.classname, dict.type_repr, method.name
                ),
            )
        })?;
        writeln!(
            writer,
            "        let fn_value = crate::tl_value_from_ptr({symbol} as *mut c_void);"
        )?;
        writeln!(
            writer,
            "        if fn_value.as_raw().is_null() {{ return ::std::ptr::null_mut(); }}"
        )?;
        writeln!(
            writer,
            "        crate::tl_dict_builder_push_ext(builder, c\"{}\".as_ptr(), {}, c\"{}\".as_ptr(), fn_value);",
            escape_c_literal(&method.name),
            method_id,
            escape_c_literal(signature)
        )?;
    }
    writeln!(
        writer,
        "        let dict = crate::tl_dict_builder_finish(builder);"
    )?;
    writeln!(writer, "        crate::tl_dict_builder_dispose(builder);")?;
    writeln!(writer, "        dict")?;
    writeln!(writer, "    }}")?;
    writeln!(writer, "}}\n")?;
    Ok(())
}

fn escape_c_literal(input: &str) -> String {
    let mut escaped = String::with_capacity(input.len());
    for ch in input.chars() {
        match ch {
            '\\' => escaped.push_str("\\\\"),
            '\"' => escaped.push_str("\\\""),
            _ => escaped.push(ch),
        }
    }
    escaped
}
